
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>hw3</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-10-25"><meta name="DC.source" content="hw3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">1 LSI system characterization</a></li><li><a href="#27">2 Fourier transform of periodic signals</a></li><li><a href="#47">3 Gabor filter</a></li><li><a href="#70">4 Deconvolution of the Haemodynamic Response</a></li><li><a href="#89">5 Sampling and aliasing</a></li></ul></div><pre class="codeinput">close <span class="string">all</span>; clear
</pre><h2 id="2">1 LSI system characterization</h2><div><ul><li>a) check linearity and shift-invariance</li></ul></div><pre class="codeinput">N=64;
I = eye(64); <span class="comment">% generate a series of impulse input</span>
</pre><p>System 1 is <b>not</b> shift-invariant. The reponse gain changes with time.</p><pre class="codeinput">figure; hold <span class="string">on</span>; grid <span class="string">on</span>
positions = [1 2 4 8 62];
<span class="keyword">for</span> p=positions+1
    output = unknownSystem1(I(:,p));
    line = plot(output);
    set(line,<span class="string">'Displayname'</span>,[<span class="string">'impulse response at '</span>,num2str(p-1)]);
<span class="keyword">end</span>
xlabel(<span class="string">'time'</span>)
ylabel(<span class="string">'response'</span>)
title(<span class="string">'Impulse response of system 1 at different positions'</span>)
legend(<span class="string">'Location'</span>,<span class="string">'north'</span>)
</pre><img vspace="5" hspace="5" src="hw3_01.png" alt=""> <p>System 1 is <b>nonlinear</b>.</p><pre class="codeinput">output1 = unknownSystem1(I(:,positions(1)));
output2 = unknownSystem1(I(:,positions(2)));
sumOfOutput = output1+output2;
sumOfInput = I(:,positions(1))+I(:,positions(2));
<span class="keyword">if</span> all(sumOfOutput == unknownSystem1(sumOfInput))
    disp(<span class="string">'System 1 is possibly linear'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'System 1 is nonlinear'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">System 1 is nonlinear
</pre><p>System 2 <b>is</b> shift-invariant</p><pre class="codeinput">figure; hold <span class="string">on</span>; grid <span class="string">on</span>
<span class="comment">%positions = randperm(N,4);</span>
positions = [1 2 4 8];
<span class="keyword">for</span> p=positions+1
    output = unknownSystem2(I(:,p));
    line = plot(output);
    set(line,<span class="string">'Displayname'</span>,[<span class="string">'impulse response at '</span>,num2str(p-1)]);
<span class="keyword">end</span>
xlabel(<span class="string">'time'</span>)
ylabel(<span class="string">'response'</span>)
title(<span class="string">'Impulse response of system 2 at different positions'</span>)
legend(<span class="string">'Location'</span>,<span class="string">'north'</span>)
</pre><img vspace="5" hspace="5" src="hw3_02.png" alt=""> <p>circular boundary handling also holds for very late impulse.</p><pre class="codeinput">figure
figure; hold <span class="string">on</span>; grid <span class="string">on</span>
<span class="keyword">for</span> p=positions+54
    output = unknownSystem2(I(:,p));
    line = plot(output);
    set(line,<span class="string">'Displayname'</span>,[<span class="string">'impulse response at '</span>,num2str(p-1)]);
<span class="keyword">end</span>
xlabel(<span class="string">'time'</span>)
ylabel(<span class="string">'response'</span>)
title(<span class="string">'Impulse response of system 2 at different positions'</span>)
legend(<span class="string">'Location'</span>,<span class="string">'north'</span>)
</pre><img vspace="5" hspace="5" src="hw3_03.png" alt=""> <img vspace="5" hspace="5" src="hw3_04.png" alt=""> <p>System 2 is <b>nonlinear</b> because of a nonzero offset</p><pre class="codeinput">output1 = unknownSystem2(I(:,positions(4)));
output2 = unknownSystem2(I(:,positions(2)));
sumOfOutput = output1+output2;
sumOfInput = I(:,positions(4))+I(:,positions(2));
<span class="keyword">if</span> all(sumOfOutput == unknownSystem2(sumOfInput))
    disp(<span class="string">'System 2 is possibly linear'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'System 2 is nonlinear'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">System 2 is nonlinear
</pre><pre class="codeinput">figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(sumOfOutput)
plot(unknownSystem2(sumOfInput))
xlabel(<span class="string">'time'</span>);ylabel(<span class="string">'response'</span>)
legend(<span class="string">'sum on output side'</span>,<span class="string">'sum on input side'</span>,<span class="string">'Location'</span>,<span class="string">'northeast'</span>)
title(<span class="string">'nonlinearity of system 2'</span>)
</pre><img vspace="5" hspace="5" src="hw3_05.png" alt=""> <p>System 3 <b>is</b> shift-invariant, circular boundary handling also holds for very late impulse.</p><pre class="codeinput">figure; hold <span class="string">on</span>; grid <span class="string">on</span>
<span class="comment">% positions = randperm(N,4)</span>
positions = [1 2 4 8];
<span class="keyword">for</span> p=positions+1
    output = unknownSystem3(I(:,p));
    line = plot(output);
    set(line,<span class="string">'Displayname'</span>,[<span class="string">'impulse response at '</span>,num2str(p-1)]);
<span class="keyword">end</span>
xlabel(<span class="string">'time'</span>)
ylabel(<span class="string">'response'</span>)
title(<span class="string">'Impulse response of system 3 at different positions'</span>)
legend(<span class="string">'Location'</span>,<span class="string">'north'</span>)
</pre><img vspace="5" hspace="5" src="hw3_06.png" alt=""> <p>circular boundary handling also holds for very late impulse.</p><pre class="codeinput">figure
figure; hold <span class="string">on</span>; grid <span class="string">on</span>
<span class="keyword">for</span> p=positions+54
    output = unknownSystem3(I(:,p));
    line = plot(output);
    set(line,<span class="string">'Displayname'</span>,[<span class="string">'impulse response at '</span>,num2str(p+1)]);
<span class="keyword">end</span>
xlabel(<span class="string">'time'</span>)
ylabel(<span class="string">'response'</span>)
title(<span class="string">'Impulse response of system 3 at different positions'</span>)
legend(<span class="string">'Location'</span>,<span class="string">'north'</span>)
</pre><img vspace="5" hspace="5" src="hw3_07.png" alt=""> <img vspace="5" hspace="5" src="hw3_08.png" alt=""> <p>System 3 <b>is</b> possibly linear</p><pre class="codeinput">positions = randi(N,1,4);
g1=1;g2=1;
output1 = unknownSystem3(I(:,positions(1)));
output2 = unknownSystem3(I(:,positions(2)));
sumOfOutput = g1*output1+g2*output2;
sumOfInput = g1*I(:,positions(1))+g2*I(:,positions(2));
<span class="keyword">if</span> all(sumOfOutput == unknownSystem3(sumOfInput))
    disp(<span class="string">'System 3 is possibly linear'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'System 3 is nonlinear'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">System 3 is possibly linear
</pre><div><ul><li>b) response to sinusoid</li></ul></div><pre class="language-matlab">
<span class="keyword">function</span> [amp,phaseDiff]=isSameFreqSinusoid(f,system)
    <span class="comment">% The following equation test whether the output is of the same</span>
    <span class="comment">% frequency with the input. The test uses linear regression, which is</span>
    <span class="comment">% equivalent with calculating the Fourier coefficients of the output</span>
    <span class="comment">% corresponding to the input frequency term and the DC term, and check</span>
    <span class="comment">% if the regression is complete.</span>
    N=64;t = (0:(N-1))';
<span class="comment">    %% generate input with desired frequency and random phase</span>
    inputPhase = randi(N,1)*2*pi/N;
    input = cos(f*t + inputPhase)+1;
<span class="comment">    %% compute output</span>
    output = system(input);
<span class="comment">    %% generate orthonormal basis of the subspace</span>
    X = [ones(N,1),cos(f*t),-sin(f*t)]; <span class="comment">% -sin because of conjugate in complex inner products</span>
<span class="comment">    %% linear regression</span>
    <span class="comment">% The SVD method gives a slightly different pseudoinverse matrix and</span>
    <span class="comment">% the error is at the same order as using the backslash method in</span>
    <span class="comment">% MATLAB. I use backslash instead for concisement</span>
    b = (X'*X)\X'*output; <span class="comment">% standard linear regression operation (projection of r to X's subspace, analogous to vector projection)</span>
<span class="comment">%     [U,S,V] = svd(X);</span>
<span class="comment">%     Si = zeros(size(S'));</span>
<span class="comment">%     for ii = 1:min(size(X))</span>
<span class="comment">%         Si(ii,ii) = 1./S(ii,ii);</span>
<span class="comment">%     end</span>
<span class="comment">%     b = V*Si*U'*output;</span>
<span class="comment">%     X*b-output</span>
<span class="comment">    %% examine if regression is complete</span>
    result = all(abs(X*b-output)&lt;1e-10); <span class="comment">% to avoid floating number error, equivalent to using round and ==</span>
    <span class="keyword">if</span> result 
        disp(<span class="string">'output is in the same subspace'</span>);
    <span class="keyword">else</span>
        disp(<span class="string">'output is outside the input subspace'</span>);
    <span class="keyword">end</span>
<span class="comment">    %% calculate amplitude and phase shift</span>
    amp = sqrt(b(2)^2+b(3)^2);
    phase = atan2(b(3),b(2));
    phaseDiff = phase - inputPhase;
    phaseDiff = mod(phaseDiff+pi,2*pi)-pi; <span class="comment">% so that -pi&lt;=phaseDiff&lt;pi</span>
    
    

</pre><pre class="codeinput"><span class="keyword">for</span> sys = 1:2
    eval(sprintf(<span class="string">'system = @unknownSystem%d'</span>,sys));
    disp <span class="string">system</span>
    <span class="keyword">for</span> f = [1,2,4,8]
        disp([<span class="string">'frequency: '</span>,num2str(f),<span class="string">'*2*pi/64'</span>])
        isSameFreqSinusoid(f*2*pi/N,system);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
system =

  function_handle with value:

    @unknownSystem1

system
frequency: 1*2*pi/64
output is outside the input subspace
frequency: 2*2*pi/64
output is outside the input subspace
frequency: 4*2*pi/64
output is outside the input subspace
frequency: 8*2*pi/64
output is outside the input subspace

system =

  function_handle with value:

    @unknownSystem2

system
frequency: 1*2*pi/64
output is outside the input subspace
frequency: 2*2*pi/64
output is outside the input subspace
frequency: 4*2*pi/64
output is outside the input subspace
frequency: 8*2*pi/64
output is outside the input subspace
</pre><p>Only <b>System 3</b> project sinusoids into sinuisoid of the same frequency.</p><pre class="codeinput">system = @unknownSystem3
freqs = [1,2,4,8];
<span class="keyword">for</span> f = freqs
    disp([<span class="string">'frequency: '</span>,num2str(f),<span class="string">'*2*pi/64'</span>])
    [amplitude(f),phaseShift(f)]=isSameFreqSinusoid(f*2*pi/N,@unknownSystem3);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
system =

  function_handle with value:

    @unknownSystem3

frequency: 1*2*pi/64
output is in the same subspace
frequency: 2*2*pi/64
output is in the same subspace
frequency: 4*2*pi/64
output is in the same subspace
frequency: 8*2*pi/64
output is in the same subspace
</pre><p>The amplitude and phase of the output is predicted by the Fourier transfrom of system's impulse response</p><pre class="codeinput">impulseResponse = unknownSystem3(I(:,1));
impulseResponseDFT = fft(impulseResponse);
ampF = abs(impulseResponseDFT); phaseF = angle(impulseResponseDFT);
figure
ax1=subplot(2,1,1); hold <span class="string">on</span>; grid <span class="string">on</span>
bar((-N/2):(N/2-1),fftshift(ampF))
bar(freqs,amplitude(freqs))
legend(<span class="string">'impulse response'</span>, <span class="string">'output/input'</span>)
ylabel(<span class="string">'amplitude'</span>)
ax2=subplot(2,1,2); hold <span class="string">on</span>; grid <span class="string">on</span>
bar((-N/2):(N/2-1),fftshift(phaseF))
bar(freqs,phaseShift(freqs))
legend(<span class="string">'impulse response'</span>, <span class="string">'output-input'</span>)
ylabel(<span class="string">'phase (rad)'</span>)
linkaxes([ax1 ax2],<span class="string">'x'</span>)
xlabel(sprintf(<span class="string">'freq (cycle/%dsample)'</span>,N))
</pre><img vspace="5" hspace="5" src="hw3_09.png" alt=""> <pre class="codeinput"><span class="keyword">if</span> all(abs(amplitude(freqs) - ampF(freqs+1)')&lt;1e-7)
    disp(<span class="string">'Amplitudes matches!'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'Amplitudes not match'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Amplitudes matches!
</pre><pre class="codeinput"><span class="keyword">if</span> all(abs(phaseShift(freqs) - phaseF(freqs+1)')&lt;1e-7)
    disp(<span class="string">'Phases matches!'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'Phases not match'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Phases matches!
</pre><div><ul><li>c)</li></ul></div><p><b>System 1</b> is neither linear nor shift-invariant, and it doesn't project siusoids into the sinusoid subspaces with same frequency.</p><p><b>System 2</b> is nonlinear but shift-invariant, and it doesn't project siusoids into the sinusoid subspaces with same frequency.</p><p><b>System</b> 3 seems both linear and shift-invariant, and it projects siusoids into the sinusoid subspaces with same frequency.</p><p><b>Linearity</b> and <b>shift-invariance</b> and <b>*indepedent properties</b>* so that they can be tested <b>*seperately</b>*, but only if a system is both linear and shift-invariant, its response to sinuisoid would be a sinusoid of the same frequency and the output gain and phase shift relative to input can be predicted by the Fourier transform of the system's impulse reponse.</p><p>So if a system always output a sinusoid given any sinusoid input, with a fixed gain and phase shift that do not vary with input strength and phase, then this system is <b>*guarenteed</b>* to be a LSI system.</p><h2 id="27">2 Fourier transform of periodic signals</h2><div><ul><li>a)</li></ul></div><pre class="codeinput">N=2048;
n = 1:N;
sig = mod(n,32)/32; <span class="comment">% generate a sawtooth</span>
figure;plot((1:N)/8192,sig);xlabel(<span class="string">'time (s)'</span>);
xlim([0 N/8192]);title(<span class="string">'a sawtooth signal'</span>)
</pre><img vspace="5" hspace="5" src="hw3_10.png" alt=""> <pre class="codeinput">sound(sig,8192)
</pre><p><b>Duration</b> is 2048/8192Hz = 0.25 seconds.</p><p><b>Period</b> is 32/8192Hz = 2^-8 = 0.039 seconds. freqency is 2^8=256 Hz, closest to middle C (C4, 261.6Hz)</p><div><ul><li>b)</li></ul></div><pre class="codeinput">sigF = fft(sig);
figure
bar((-N/2):(N/2-1),fftshift(abs(sigF)))
ylabel(<span class="string">'amplitude'</span>)
ticks=-(N/2):256:(N/2-1);
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf(<span class="string">'freq (Hz)'</span>))
title(<span class="string">'Fourier amplitude spectrum of the sawtooth signal'</span>)
</pre><img vspace="5" hspace="5" src="hw3_11.png" alt=""> <p>There are huge gaps between bars, only multiples of 256 Hz have nonzero amplitudes.</p><p>Generally, the regular spaced peak pattern in frequency domain indicates a perodity in time domain.</p><p>period can be determined by the inverse of spacing between the peaks. For the spectrum above, spacing is 256Hz and period is (1/256) seconds.</p><p>For a sawtooth with a different period,</p><pre class="codeinput">sig24 = mod(n,24)/24; <span class="comment">% generate a new sawtooth of 24-sample period</span>
<span class="comment">% the frequency of this signal is 8192/24 = 1024/3 Hz</span>
sig24F = fft(sig24);
</pre><p>The spectrum also peaks regularly:</p><pre class="codeinput">figure
bar((-N/2):(N/2-1),fftshift(abs(sig24F)))
ylabel(<span class="string">'amplitude'</span>)
ticks=-1024:(2048/24*3):1023;
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf(<span class="string">'freq (Hz)'</span>))
title(<span class="string">'Fourier amplitude spectrum of another sawtooth signal'</span>)
</pre><img vspace="5" hspace="5" src="hw3_12.png" alt=""> <p>The spectrum peaks every time the frequency is a multiple of 1024/3 Hz. It has a period of 3/1024 seconds.</p><div><ul><li>c)</li></ul></div><p>now for another periodic signal <img src="hw3_eq00649005139556846024.png" alt="$(1+cos(2\pi*64*n/N)^2$" style="width:154px;height:16px;"></p><pre class="codeinput">N=2048;
sigG = (1+cos(n*2*pi*64/N)).^2;
sigGF = fft(sigG);
figure
bar((-N/2):(N/2-1),fftshift(abs(sigGF)))
ylabel(<span class="string">'amplitude'</span>)
ticks=-1024:256:1023;
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf(<span class="string">'freq (Hz)'</span>))
title(<span class="string">'Fourier amplitude spectrum of another periodic signal'</span>)
</pre><img vspace="5" hspace="5" src="hw3_13.png" alt=""> <p>This spectrum is only nonzero at frequency 0, 256 and 512 Hz.</p><p>So it still has a period of 2^-8 second, or 32 samples.</p><pre class="codeinput">figure; hold <span class="string">on</span>
nT = 1:32;
plot(nT/8192,sig(nT));
plot(nT/8192,sigG(nT));
legend(<span class="string">'f(n)'</span>,<span class="string">'g(n'</span>)
xlabel(<span class="string">'time (s)'</span>)
title(<span class="string">'one period of two signals'</span>)
</pre><img vspace="5" hspace="5" src="hw3_14.png" alt=""> <p>the wave looks more smooth, as in the Fourier spectrum there is no high frequency components, but is only a linear combination of 256 Hz and 512 Hz sinusoids and a DC shift.</p><p>And the timbre of g(n) sounds brighter.</p><h2 id="47">3 Gabor filter</h2><div><ul><li>a)</li></ul></div><pre class="codeinput">n = -12:12;
sigma=3.5;
omega=10*2*pi/64;
gabor=exp(-(n/sigma).^2/2).*cos(omega*n);
figure
plot(n,gabor);title(<span class="string">'gabor filter'</span>)
xlabel(<span class="string">'space'</span>)
ylabel(<span class="string">'response'</span>)
</pre><img vspace="5" hspace="5" src="hw3_15.png" alt=""> <pre class="codeinput">gaborF=fft(gabor,64);
figure
plot(-32:31,fftshift(abs(gaborF)))
title(<span class="string">'Fourier amplitude spectrum of gabor'</span>)
xlabel(<span class="string">'spatial frequency k (cycle/64 sample)'</span>)
ylabel(<span class="string">'amplitude'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="hw3_16.png" alt=""> <p>This is a <b>bandpass filter</b> that selectively filter frequency of 10*2pi/64 samples. It looks like two gaussian functions centered at 10 and -10. This shape results from the convolution of Gaussian function's spectrum (which is another Gaussian) and sinusoid function (impulse at k=+/-10 ).</p><p>omega determines the bandpass frequency and 1/sigma determines the width of the band. If I let omega=12*2pi/64 and sigma=1</p><pre class="codeinput">gaborWiderAt12 = exp(-(n).^2/2).*cos(omega*1.2*n);
gaborWiderAt12F=fft(gaborWiderAt12,64);
figure
plot(-32:31,fftshift(abs(gaborWiderAt12F)))
title(<span class="string">'Fourier amplitude spectrum of another gabor'</span>)
xlabel(<span class="string">'spatial frequency k (cycle/64 sample)'</span>)
ylabel(<span class="string">'amplitude'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="hw3_17.png" alt=""> <p>I get two wider Gaussian centered at k=+/- 12</p><div><ul><li>b )</li></ul></div><p>Among all sinusoid <img src="hw3_eq18109780525297858785.png" alt="$cos(2pifn/64)$" style="width:90px;height:15px;">, f = 10 will give the largest response.</p><p>because the convolution at position 0</p><p><img src="hw3_eq03287783137606965153.png" alt="$$\sum_{n=-12}^{12} gabor(-n)cos(2\pi f n/64)$$" style="width:189px;height:43px;"></p><p>is the real part of the f'th Fourier coefficient. and since gabor is evenly symmetric, thus the imagionary parts are all zero, the real part is just the amplitude.</p><p>Gabor is the product of a Gaussian function and a sinusoid in space domain so the spectrum in the frequency domain is the convolution of Gaussian's spectrum and two impulse at corresponding sinusoid frequency (positive and negative). Since Gaussian's spectrum peaks at 0, Gabor's spectrum should peak at corresponding sinusoid frequency as well.</p><p>the max amplitude is at the position f = 10</p><pre class="codeinput">[Fmax,ind] = max(abs(gaborF));
disp(ind-1)
</pre><pre class="codeoutput">    10

</pre><pre class="codeinput">figure; hold <span class="string">on</span>
plot(-32:31,fftshift(abs(gaborF)))
plot(ind-1,Fmax,<span class="string">'r*'</span>)
plot(1-ind,Fmax,<span class="string">'r*'</span>)
title(<span class="string">'peak position of Gabor''s spectrum'</span>)
xlabel(<span class="string">'spatial frequency k (cycle/64 sample)'</span>)
ylabel(<span class="string">'amplitude'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="hw3_18.png" alt=""> <p>The period of this sinusoid is 2pi/(f*2pi/64)=64/f samples</p><pre class="codeinput">64/10
figure; hold <span class="string">on</span>
plot(n,gabor);title(<span class="string">'gabor filter'</span>)
plot([6.4,6.4],[-1 1],<span class="string">'b--'</span>)
plot([6.4,6.4]*2,[-1 1],<span class="string">'b--'</span>)
plot([0,0],[-1 1],<span class="string">'b--'</span>)
plot([6.4,6.4]*-1,[-1 1],<span class="string">'b--'</span>)
plot([6.4,6.4]*-2,[-1 1],<span class="string">'b--'</span>)
xticks(-12.8:6.4:12.8)
xlabel(<span class="string">'space'</span>)
ylabel(<span class="string">'response'</span>)
</pre><pre class="codeoutput">
ans =

    6.4000

</pre><img vspace="5" hspace="5" src="hw3_19.png" alt=""> <p>By eye inspection, this is roughly the distance between peaks in the filter itself.</p><pre class="codeinput">gaborF=fft(gabor,64);
figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(-32:31,fftshift(abs(gaborF)))
plot([-32,31],[Fmax Fmax],<span class="string">'b--'</span>)
plot([-32,31],[Fmax Fmax]*0.25,<span class="string">'b--'</span>)
plot([5 5],[0 Fmax],<span class="string">'b--'</span>)
plot([15 15],[0 Fmax],<span class="string">'b--'</span>)
xticks(-35:10:35)
title(<span class="string">'Fourier amplitude spectrum of gabor'</span>)
xlabel(<span class="string">'spatial frequency (cycle/64 sample)'</span>)
</pre><img vspace="5" hspace="5" src="hw3_20.png" alt=""> <p>By eye inspection, sinusoids of frequency 5/64 cycle/sample and 15/64 cycle/sample will give about 25% of the maximal amplitude</p><div><ul><li>c)</li></ul></div><p>Indeed, these two sinusoids gives roughly 1/4 maximal response:</p><pre class="codeinput">n=1:64;
input5  = cos( 5*2*pi/64*n);
input10 = cos(10*2*pi/64*n);
input15 = cos(15*2*pi/64*n);
rLow = conv(input5 ,gabor);
rMed = conv(input10,gabor);
rHih = conv(input15,gabor);
ampLow = abs(fft(rLow,64));
display([<span class="string">'low freq response amplitude: '</span>,num2str(ampLow(5+1))])
ampMed = abs(fft(rMed,64));
display([<span class="string">'medium freq response amplitude: '</span>,num2str(ampMed(10+1))])
ampHih = abs(fft(rHih,64));
display([<span class="string">'high freq response amplitude: '</span>,num2str(ampHih(15+1))])
</pre><pre class="codeoutput">low freq response amplitude: 26.4826
medium freq response amplitude: 113.6463
high freq response amplitude: 25.7612
</pre><h2 id="70">4 Deconvolution of the Haemodynamic Response</h2><pre class="codeinput">load <span class="string">hrfDeconv.mat</span>;
figure;hold <span class="string">on</span>
plot(r);stem(x);
legend(<span class="string">'r(t)'</span>,<span class="string">'x(t)'</span>)
xlabel(<span class="string">'time (s)'</span>)
title(<span class="string">'measured activity and true activity'</span>)
</pre><img vspace="5" hspace="5" src="hw3_21.png" alt=""> <p>To convolve x with h, we can trun x into X and do Xh:</p><pre class="language-matlab">
<span class="keyword">function</span> X=createConvMat(x,M)
    <span class="comment">% size(x) should be [N,1]</span>
    xPad = [x;zeros(M-1,1)];
    <span class="keyword">for</span> ii=1:M
        X(:,ii) = circshift(xPad,ii-1);
    <span class="keyword">end</span>

</pre><pre class="codeinput">M = 15;
X = createConvMat(x,M);
</pre><p>Verify the matrix X</p><pre class="codeinput"><span class="keyword">for</span> ii = 1:5
    disp([<span class="string">'test filter '</span>,num2str(ii)])
    h = rand(M,1);
    <span class="keyword">if</span> all(X*h == conv(x,h)); disp(<span class="string">'X*h is equal to conv(x,h)'</span>); <span class="keyword">else</span>; disp(<span class="string">'Fail'</span>); <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">test filter 1
X*h is equal to conv(x,h)
test filter 2
X*h is equal to conv(x,h)
test filter 3
X*h is equal to conv(x,h)
test filter 4
X*h is equal to conv(x,h)
test filter 5
X*h is equal to conv(x,h)
</pre><p>Verified.</p><pre class="codeinput">figure;imagesc(X);colorbar;title(<span class="string">'conv matrix'</span>)
</pre><img vspace="5" hspace="5" src="hw3_22.png" alt=""> <p>X has a step-like structure. Every column is a shifted version of another.</p><div><ul><li>b)</li></ul></div><pre class="codeinput">h_opt = (X'*X)\X'*r; <span class="comment">% standard linear regression operation (projection of r to X's subspace, analogous to vector projection)</span>
<span class="comment">%     [U,S,V] = svd(X);</span>
<span class="comment">%     Si = zeros(size(S'));</span>
<span class="comment">%     for ii = 1:min(size(X))</span>
<span class="comment">%         Si(ii,ii) = 1./S(ii,ii);</span>
<span class="comment">%     end</span>
<span class="comment">%     h_opt = V*Si*U'*r;</span>
    <span class="comment">% The SVD method gives a slightly different pseudoinverse matrix and</span>
    <span class="comment">% the error is at the same order as using the backslash method in</span>
    <span class="comment">% MATLAB. I use backslash instead for concisement</span>
figure; plot(h_opt); xlabel(<span class="string">'time (s)'</span>); legend(<span class="string">'h(t)'</span>)
title(<span class="string">'Estimated Haemodynamic Response'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="hw3_23.png" alt=""> <p>The HRF curve looks like a 3/4 cycle sine wave multiplied by a decay.</p><p>It rises to peak in 5 seconds and drops into negative then recover. The positive peak is about 3 times the negative valley. It takes about 15 second for HRF to recover to baseline.</p><pre class="codeinput">r_est = conv(x,h_opt);
figure; hold <span class="string">on</span>
plot(r);plot(r_est);
legend(<span class="string">'r(t)'</span>,<span class="string">'r_{est}(t)'</span>)
xlabel(<span class="string">'time (s)'</span>)
ylabel(<span class="string">'response'</span>)
</pre><img vspace="5" hspace="5" src="hw3_24.png" alt=""> <p>The estimated HRF fits the response well.</p><div><ul><li>c)</li></ul></div><pre class="codeinput">M=15;
hF = fft(h,M);
hP = hF.*conj(hF);
figure
freqs = (0:M-1) - floor(M/2);
freqs = freqs/M;
plot(freqs,fftshift(hP))
xlabel(<span class="string">'freq (Hz)'</span>);ylabel(<span class="string">'power'</span>)
xticks(-.4:.2:.4)
title(<span class="string">'power spectrum of h(t)'</span>)
</pre><img vspace="5" hspace="5" src="hw3_25.png" alt=""> <p>h(t) is a low pass filter, only frequencies lower than 0.05 Hz are passed.</p><h2 id="89">5 Sampling and aliasing</h2><pre class="codeinput">load <span class="string">myMeasurements.mat</span>
</pre><div><ul><li>a)</li></ul></div><pre class="codeinput">p=4; <span class="comment">% subsample period</span>
figure; hold <span class="string">on</span>
plot(time/100,sig,<span class="string">'ko-'</span>)
xlabel(<span class="string">'time (s)'</span>)
DS = mod(time,p)==0;
sigDS = sig(DS);
plot(time(DS)/100,sigDS,<span class="string">'r*-'</span>)
legend(<span class="string">'original signal'</span>,<span class="string">'subsampled signal'</span>)
</pre><img vspace="5" hspace="5" src="hw3_26.png" alt=""> <p>The reduced version signal looks like another perodic signal. It doesn't provide a good summary of the original signal.</p><p>subsampling operation <b>is linear</b> but <b>not shift-invariant</b>, because it's essentially pairwise multiplication with another signal where every fourth value is 1 and otherwise 0. This operation is additive but if we shift the signal with a timestep that is not a multiple of subsampling frequency, we get a completely different signal.</p><div><ul><li>b)</li></ul></div><pre class="codeinput">N = length(time);
sigF = fft(sig);
sigDSUS = sig.*DS;
sigDSF = fft(sigDSUS);
figure; hold <span class="string">on</span>
plot((-N/2):(N/2-1),fftshift(abs(sigF)),<span class="string">'k'</span>)
plot((-N/2):(N/2-1),fftshift(abs(sigDSF)),<span class="string">'r'</span>)
<span class="comment">% plot((-N/2):(N/2-1),fftshift(abs(fft(DS))))</span>
plot([-N/p/2,-N/p/2,N/p/2,N/p/2],[0 120 120 0],<span class="string">'b--'</span>)
legend(<span class="string">'original signal'</span>,<span class="string">'subsampled then upsampled signal'</span>,<span class="string">'1/2 subsampling frequency'</span>)
ticks = (-N/2):(N/10):(N/2-1);
xticks(ticks)
xticklabels(ticks/N*100)
xlabel(<span class="string">'frequency (Hz)'</span>)
ylabel(<span class="string">'Fourier amplitude'</span>)
</pre><img vspace="5" hspace="5" src="hw3_27.png" alt=""> <p>subsampling basically copys the origianl spectrum (without DC component) four times, scales them by 1/4 and places them centered at every multiple of 1/2 subsampling frequency.</p><pre class="codeinput">close <span class="string">all</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
close all; clear
%% 1 LSI system characterization
%%
% * a) check linearity and shift-invariance
%%
N=64;
I = eye(64); % generate a series of impulse input
%%
% System 1 is *not* shift-invariant. The reponse gain changes with time. 
figure; hold on; grid on
positions = [1 2 4 8 62];
for p=positions+1
    output = unknownSystem1(I(:,p));
    line = plot(output);
    set(line,'Displayname',['impulse response at ',num2str(p-1)]);
end
xlabel('time')
ylabel('response')
title('Impulse response of system 1 at different positions')
legend('Location','north')
%%
% System 1 is *nonlinear*. 
output1 = unknownSystem1(I(:,positions(1)));
output2 = unknownSystem1(I(:,positions(2)));
sumOfOutput = output1+output2;
sumOfInput = I(:,positions(1))+I(:,positions(2));
if all(sumOfOutput == unknownSystem1(sumOfInput))
    disp('System 1 is possibly linear')
else
    disp('System 1 is nonlinear')
end
    
%%
% System 2 *is* shift-invariant
figure; hold on; grid on
%positions = randperm(N,4);
positions = [1 2 4 8];
for p=positions+1
    output = unknownSystem2(I(:,p));
    line = plot(output);
    set(line,'Displayname',['impulse response at ',num2str(p-1)]);
end
xlabel('time')
ylabel('response')
title('Impulse response of system 2 at different positions')
legend('Location','north')
%% 
% circular boundary handling also holds for very late impulse. 
figure
figure; hold on; grid on
for p=positions+54
    output = unknownSystem2(I(:,p));
    line = plot(output);
    set(line,'Displayname',['impulse response at ',num2str(p-1)]);
end
xlabel('time')
ylabel('response')
title('Impulse response of system 2 at different positions')
legend('Location','north')

%%
% System 2 is *nonlinear* because of a nonzero offset
output1 = unknownSystem2(I(:,positions(4)));
output2 = unknownSystem2(I(:,positions(2)));
sumOfOutput = output1+output2;
sumOfInput = I(:,positions(4))+I(:,positions(2));
if all(sumOfOutput == unknownSystem2(sumOfInput))
    disp('System 2 is possibly linear')
else
    disp('System 2 is nonlinear')
end

%%
figure; hold on; grid on
plot(sumOfOutput)
plot(unknownSystem2(sumOfInput))
xlabel('time');ylabel('response')
legend('sum on output side','sum on input side','Location','northeast')
title('nonlinearity of system 2')
%%
% System 3 *is* shift-invariant, circular boundary handling also holds for very late impulse.
figure; hold on; grid on
% positions = randperm(N,4)
positions = [1 2 4 8];
for p=positions+1
    output = unknownSystem3(I(:,p));
    line = plot(output);
    set(line,'Displayname',['impulse response at ',num2str(p-1)]);
end
xlabel('time')
ylabel('response')
title('Impulse response of system 3 at different positions')
legend('Location','north')
%% 
% circular boundary handling also holds for very late impulse. 
figure
figure; hold on; grid on
for p=positions+54
    output = unknownSystem3(I(:,p));
    line = plot(output);
    set(line,'Displayname',['impulse response at ',num2str(p+1)]);
end
xlabel('time')
ylabel('response')
title('Impulse response of system 3 at different positions')
legend('Location','north')

%%
% System 3 *is* possibly linear
positions = randi(N,1,4);
g1=1;g2=1;
output1 = unknownSystem3(I(:,positions(1)));
output2 = unknownSystem3(I(:,positions(2)));
sumOfOutput = g1*output1+g2*output2;
sumOfInput = g1*I(:,positions(1))+g2*I(:,positions(2));
if all(sumOfOutput == unknownSystem3(sumOfInput))
    disp('System 3 is possibly linear')
else
    disp('System 3 is nonlinear')
end

%%
% * b) response to sinusoid
%%
% <include>isSameFreqSinusoid.m</include>
%%

for sys = 1:2
    eval(sprintf('system = @unknownSystem%d',sys));
    disp system
    for f = [1,2,4,8]
        disp(['frequency: ',num2str(f),'*2*pi/64'])
        isSameFreqSinusoid(f*2*pi/N,system);
    end
end
%%        
% Only *System 3* project sinusoids into sinuisoid of the same frequency. 
system = @unknownSystem3
freqs = [1,2,4,8];
for f = freqs
    disp(['frequency: ',num2str(f),'*2*pi/64'])
    [amplitude(f),phaseShift(f)]=isSameFreqSinusoid(f*2*pi/N,@unknownSystem3);
end    
    
%%
% The amplitude and phase of the output is predicted by the Fourier transfrom of system's impulse response
impulseResponse = unknownSystem3(I(:,1));
impulseResponseDFT = fft(impulseResponse);
ampF = abs(impulseResponseDFT); phaseF = angle(impulseResponseDFT);
figure
ax1=subplot(2,1,1); hold on; grid on
bar((-N/2):(N/2-1),fftshift(ampF))
bar(freqs,amplitude(freqs))
legend('impulse response', 'output/input')
ylabel('amplitude')
ax2=subplot(2,1,2); hold on; grid on
bar((-N/2):(N/2-1),fftshift(phaseF))
bar(freqs,phaseShift(freqs))
legend('impulse response', 'output-input')
ylabel('phase (rad)')
linkaxes([ax1 ax2],'x')
xlabel(sprintf('freq (cycle/%dsample)',N))
%%
if all(abs(amplitude(freqs) - ampF(freqs+1)')<1e-7)
    disp('Amplitudes matches!')
else
    disp('Amplitudes not match')
end
%%
if all(abs(phaseShift(freqs) - phaseF(freqs+1)')<1e-7)
    disp('Phases matches!')
else
    disp('Phases not match')
end

%%
% * c)
%%
% *System 1* is neither linear nor shift-invariant, and it doesn't project
% siusoids into the sinusoid subspaces with same frequency. 
%%
% *System 2* is nonlinear but shift-invariant, and it doesn't project
% siusoids into the sinusoid subspaces with same frequency. 
%%
% *System* 3 seems both linear and shift-invariant, and it projects
% siusoids into the sinusoid subspaces with same frequency. 
%%
% *Linearity* and *shift-invariance* and **indepedent properties** so that they can
% be tested **seperately**, but only if a system is both linear and
% shift-invariant, its response to sinuisoid would be a sinusoid of the
% same frequency and the output gain and phase shift relative to input can
% be predicted by the Fourier transform of the system's impulse reponse.
%%
% So
% if a system always output a sinusoid given any sinusoid input, with a
% fixed gain and phase shift that do not vary with input strength and
% phase, then this system is **guarenteed** to be a LSI system. 
%% 2 Fourier transform of periodic signals
%%
% * a)
%%
N=2048;
n = 1:N;
sig = mod(n,32)/32; % generate a sawtooth
figure;plot((1:N)/8192,sig);xlabel('time (s)');
xlim([0 N/8192]);title('a sawtooth signal')
%%
sound(sig,8192)
%%
% *Duration* is 2048/8192Hz = 0.25 seconds. 
%%
% *Period* is 32/8192Hz = 2^-8 = 0.039 seconds. freqency is 2^8=256 Hz, closest to
% middle C (C4, 261.6Hz)
%%
% * b)
sigF = fft(sig);
figure
bar((-N/2):(N/2-1),fftshift(abs(sigF)))
ylabel('amplitude')
ticks=-(N/2):256:(N/2-1);
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf('freq (Hz)'))
title('Fourier amplitude spectrum of the sawtooth signal')

%%
% There are huge gaps between bars, only multiples of 256 Hz have nonzero amplitudes.  
%%
% Generally, the regular spaced peak
% pattern in frequency domain
% indicates a perodity in time domain.
%%
% period can be determined by the inverse of spacing between the peaks. 
% For the spectrum above, spacing is 256Hz and period is (1/256) seconds. 
%%
% For a sawtooth with a different period, 
sig24 = mod(n,24)/24; % generate a new sawtooth of 24-sample period 
% the frequency of this signal is 8192/24 = 1024/3 Hz
sig24F = fft(sig24);
%%
% The spectrum also peaks regularly: 
figure
bar((-N/2):(N/2-1),fftshift(abs(sig24F)))
ylabel('amplitude')
ticks=-1024:(2048/24*3):1023;
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf('freq (Hz)'))
title('Fourier amplitude spectrum of another sawtooth signal')

%%
% The spectrum peaks every time the frequency is a multiple of
% 1024/3 Hz. It has a period of 3/1024 seconds. 
%%
% * c)
%%
% now for another periodic signal $(1+cos(2\pi*64*n/N)^2$
N=2048;
sigG = (1+cos(n*2*pi*64/N)).^2;
sigGF = fft(sigG);
figure
bar((-N/2):(N/2-1),fftshift(abs(sigGF)))
ylabel('amplitude')
ticks=-1024:256:1023;
xticks(ticks)
xticklabels(ticks/N*8192)
xlabel(sprintf('freq (Hz)'))
title('Fourier amplitude spectrum of another periodic signal')
%%
% This spectrum is only nonzero at frequency 0, 256 and 512 Hz. 
%%
% So it still has a period of 2^-8 second, or 32 samples. 
%%
figure; hold on
nT = 1:32;
plot(nT/8192,sig(nT));
plot(nT/8192,sigG(nT));
legend('f(n)','g(n')
xlabel('time (s)')
title('one period of two signals')
%%
% the wave looks more smooth, as in the Fourier spectrum there is no high
% frequency components, but is only a linear combination of 256 Hz and 512
% Hz sinusoids and a DC shift. 

%%
% And the timbre of g(n) sounds brighter. 
%% 3 Gabor filter
%%
% * a)
%%
n = -12:12;
sigma=3.5;
omega=10*2*pi/64;
gabor=exp(-(n/sigma).^2/2).*cos(omega*n);
figure
plot(n,gabor);title('gabor filter')
xlabel('space')
ylabel('response')
%%
gaborF=fft(gabor,64);
figure
plot(-32:31,fftshift(abs(gaborF)))
title('Fourier amplitude spectrum of gabor')
xlabel('spatial frequency k (cycle/64 sample)')
ylabel('amplitude')
grid on
%%
% This is a *bandpass filter* that selectively filter frequency of 10*2pi/64
% samples.
% It looks like two gaussian functions centered at 10 and -10.
% This shape results from the convolution of Gaussian function's spectrum
% (which is another Gaussian) and sinusoid function (impulse at k=+/-10 ). 
%%
% omega determines the bandpass frequency and 1/sigma determines the width
% of the band. If I let omega=12*2pi/64 and sigma=1
gaborWiderAt12 = exp(-(n).^2/2).*cos(omega*1.2*n);
gaborWiderAt12F=fft(gaborWiderAt12,64);
figure
plot(-32:31,fftshift(abs(gaborWiderAt12F)))
title('Fourier amplitude spectrum of another gabor')
xlabel('spatial frequency k (cycle/64 sample)')
ylabel('amplitude')
grid on
%%
% I get two wider Gaussian centered at k=+/- 12
%%
% * b )
%%
% Among all sinusoid $cos(2pifn/64)$, f = 10 will give the largest response. 
%%
% because the convolution at position 0
%%
% $$\sum_{n=-12}^{12} gabor(-n)cos(2\pi f n/64)$$
%%
% is the real part of the f'th Fourier coefficient. and since gabor
% is evenly symmetric, thus the imagionary parts are all zero, the real
% part is just the amplitude. 
%%
% Gabor is the product of a Gaussian function and a sinusoid in space
% domain so the spectrum in the frequency domain is the convolution of Gaussian's spectrum and two
% impulse at corresponding sinusoid frequency (positive and negative). Since Gaussian's spectrum
% peaks at 0, Gabor's spectrum should peak at corresponding sinusoid
% frequency as well. 
%% 
% the max amplitude is at the position f = 10
[Fmax,ind] = max(abs(gaborF));
disp(ind-1)
%%
figure; hold on
plot(-32:31,fftshift(abs(gaborF)))
plot(ind-1,Fmax,'r*')
plot(1-ind,Fmax,'r*')
title('peak position of Gabor''s spectrum')
xlabel('spatial frequency k (cycle/64 sample)')
ylabel('amplitude')
grid on

%%
% The period of this sinusoid is 2pi/(f*2pi/64)=64/f samples
64/10
figure; hold on
plot(n,gabor);title('gabor filter')
plot([6.4,6.4],[-1 1],'bREPLACE_WITH_DASH_DASH')
plot([6.4,6.4]*2,[-1 1],'bREPLACE_WITH_DASH_DASH')
plot([0,0],[-1 1],'bREPLACE_WITH_DASH_DASH')
plot([6.4,6.4]*-1,[-1 1],'bREPLACE_WITH_DASH_DASH')
plot([6.4,6.4]*-2,[-1 1],'bREPLACE_WITH_DASH_DASH')
xticks(-12.8:6.4:12.8)
xlabel('space')
ylabel('response')
%%
% By eye inspection, this is roughly the distance between peaks in the
% filter itself. 
%%
gaborF=fft(gabor,64);
figure; hold on; grid on
plot(-32:31,fftshift(abs(gaborF)))
plot([-32,31],[Fmax Fmax],'bREPLACE_WITH_DASH_DASH')
plot([-32,31],[Fmax Fmax]*0.25,'bREPLACE_WITH_DASH_DASH')
plot([5 5],[0 Fmax],'bREPLACE_WITH_DASH_DASH')
plot([15 15],[0 Fmax],'bREPLACE_WITH_DASH_DASH')
xticks(-35:10:35)
title('Fourier amplitude spectrum of gabor')
xlabel('spatial frequency (cycle/64 sample)')
%% 
% By eye inspection, sinusoids of frequency 5/64 cycle/sample and 15/64
% cycle/sample will give about 25% of the maximal amplitude
%%
% * c)
%%
% Indeed, these two sinusoids gives roughly 1/4 maximal response: 
%%
%
%%
n=1:64;
input5  = cos( 5*2*pi/64*n);
input10 = cos(10*2*pi/64*n);
input15 = cos(15*2*pi/64*n);
rLow = conv(input5 ,gabor); 
rMed = conv(input10,gabor);
rHih = conv(input15,gabor);
ampLow = abs(fft(rLow,64)); 
display(['low freq response amplitude: ',num2str(ampLow(5+1))])
ampMed = abs(fft(rMed,64));
display(['medium freq response amplitude: ',num2str(ampMed(10+1))])
ampHih = abs(fft(rHih,64)); 
display(['high freq response amplitude: ',num2str(ampHih(15+1))])
%% 4 Deconvolution of the Haemodynamic Response
%%
%%
load hrfDeconv.mat;
figure;hold on
plot(r);stem(x);
legend('r(t)','x(t)')
xlabel('time (s)')
title('measured activity and true activity')
%%
% To convolve x with h, we can trun x into X and do Xh: 
%%
% <include>createConvMat.m</include>
%%
M = 15;
X = createConvMat(x,M);
%%
% Verify the matrix X
for ii = 1:5
    disp(['test filter ',num2str(ii)])
    h = rand(M,1);
    if all(X*h == conv(x,h)); disp('X*h is equal to conv(x,h)'); else; disp('Fail'); end
end
%%
% Verified.
%%
figure;imagesc(X);colorbar;title('conv matrix')
%%
% X has a step-like structure. Every column is a shifted version of
% another. 
%%
% * b)
%%
h_opt = (X'*X)\X'*r; % standard linear regression operation (projection of r to X's subspace, analogous to vector projection)
%     [U,S,V] = svd(X);
%     Si = zeros(size(S'));
%     for ii = 1:min(size(X))
%         Si(ii,ii) = 1./S(ii,ii);
%     end
%     h_opt = V*Si*U'*r;
    % The SVD method gives a slightly different pseudoinverse matrix and
    % the error is at the same order as using the backslash method in
    % MATLAB. I use backslash instead for concisement
figure; plot(h_opt); xlabel('time (s)'); legend('h(t)')
title('Estimated Haemodynamic Response')
grid on
%%
% The HRF curve looks like a 3/4 cycle sine wave multiplied by a decay. 
%%
% It rises to peak in 5 seconds and drops into negative then recover. The
% positive peak is about 3 times the negative valley. It takes about 15 second
% for HRF to recover to baseline. 
%%
r_est = conv(x,h_opt);
figure; hold on
plot(r);plot(r_est);
legend('r(t)','r_{est}(t)')
xlabel('time (s)')
ylabel('response')
%%
% The estimated HRF fits the response well. 
%%
% * c)
%%
M=15;
hF = fft(h,M);
hP = hF.*conj(hF);
figure
freqs = (0:M-1) - floor(M/2);
freqs = freqs/M;
plot(freqs,fftshift(hP))
xlabel('freq (Hz)');ylabel('power')
xticks(-.4:.2:.4)
title('power spectrum of h(t)')
%%
% h(t) is a low pass filter, only frequencies lower than 0.05 Hz are passed. 
%% 5 Sampling and aliasing
load myMeasurements.mat
%%
% * a)
%%
p=4; % subsample period
figure; hold on
plot(time/100,sig,'ko-')
xlabel('time (s)')
DS = mod(time,p)==0;
sigDS = sig(DS);
plot(time(DS)/100,sigDS,'r*-')
legend('original signal','subsampled signal')
%%
% The reduced version signal looks like another perodic signal. It doesn't provide a good
% summary of the original signal. 
%%
% subsampling operation *is linear* but *not shift-invariant*, because it's
% essentially pairwise multiplication with another signal where every
% fourth value is 1 and otherwise 0. This operation is additive but if we
% shift the signal with a timestep that is not a multiple of subsampling
% frequency, we get a completely different signal. 
%%
% * b)
%%
N = length(time);
sigF = fft(sig);
sigDSUS = sig.*DS;
sigDSF = fft(sigDSUS);
figure; hold on
plot((-N/2):(N/2-1),fftshift(abs(sigF)),'k')
plot((-N/2):(N/2-1),fftshift(abs(sigDSF)),'r')
% plot((-N/2):(N/2-1),fftshift(abs(fft(DS))))
plot([-N/p/2,-N/p/2,N/p/2,N/p/2],[0 120 120 0],'bREPLACE_WITH_DASH_DASH')
legend('original signal','subsampled then upsampled signal','1/2 subsampling frequency')
ticks = (-N/2):(N/10):(N/2-1);
xticks(ticks)
xticklabels(ticks/N*100)
xlabel('frequency (Hz)')
ylabel('Fourier amplitude')
%%
% subsampling basically copys the origianl spectrum (without DC component) four times, scales them by 1/4 and places 
% them centered at every multiple of 1/2 subsampling frequency. 
%%
close all
##### SOURCE END #####
--></body></html>